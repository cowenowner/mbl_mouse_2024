% CONV_GAUSS2D  2-D gaussian convolution.%        Convolves a guassian filter over each row of the input.  This is %        equivilent to running the input through a bank of %        cells, each having a gaussian weighting function over %        its local area.  Spacing of the guassian filters can%        be varied from 1 up.  Spaced filter locations are calculated%        from the center outward.  Use to smooth%        a matrix or reduce the size. %       %      [output] = conv_gauss(input, sigmax, sigmay, ...%                                 [spx], [spy], [cut_off], ['valid'])%          %           input - input matrix%           sigmax - std. dev. of gaussian in x (vertical) direction%           sigmay - std. dev. of gaussian in y (horizontal) direction%           spx [1] - filter spacing.  Takes one value every spx units.%                 (if spx is not even, center spacing will be off by one) %           spy [1] - y dimension filter spacing.    %           cut_off[.01] - abs. value of lowest gaussian value to use in filter%           shape['valid'] - how to handle the edges.  Matrix returned %              is only the valid area without zero padded edges.  %              Use 'same' to keep the output vector the same size as %              the input vector.%%         If input matrix has more than one row, filter is run%         over each row.%         Filters are normalized so that their coefficients sum to one.%         This insures that the output values will be comparable to the%         input values.function [output] = conv_gauss(input, sigmax, sigmay, spx, spy, cut_off, shape)if (nargin <4) spx = 1; end;if (nargin <5) spy = 1; end;if (nargin <6) cut_off = .01; end;if (nargin <7) shape = 'valid'; end;[rows, cols] = size(input);upper_cutx = round(sqrt(-2*sigmax^2*log(cut_off)));lower_cutx = -upper_cutx;upper_cuty = round(sqrt(-2*sigmay^2*log(cut_off)));lower_cuty = -upper_cuty;if (2*upper_cutx+1>=cols | 2*upper_cuty+1>=rows)  error ('Filtersize exceeds number of columns or rows in input');   end;filt_ix = lower_cutx:upper_cutx;filt_iy = lower_cuty:upper_cuty;[X Y] = meshgrid(filt_ix, filt_iy);filt_vals = exp(-(X.^2)./(2*sigmax^2) - (Y.^2)./(2*sigmay^2));filt_vals = filt_vals/sum(sum(filt_vals));output = conv2(input, filt_vals, shape);[rows, cols] = size(output);if (spx~=1)   centerx = round(cols/2);   half_spx = round(spx/2);   right_halfx =  centerx+half_spx:spx:cols;   left_halfx =  fliplr(centerx-half_spx:-spx:1);   spaced_filter_locx = [left_halfx right_halfx];   output = output(:,spaced_filter_locx);end;if (spy~=1)   centery = round(cols/2);   half_spy = round(spy/2);   right_halfy =  centery+half_spy:spy:cols;   left_halfy =  fliplr(centery-half_spy:-spy:1);   spaced_filter_locy = [left_halfy right_halfy];   output = output(spaced_filter_locy, :);end;return;